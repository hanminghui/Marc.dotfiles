# ==================================================
# ┌────────────────────────────────────────────────┐
# │                    Comments                    │
# └────────────────────────────────────────────────┘

snippet / "comment one line"
/* $1 */
endsnippet

snippet /* "comment lines"
/* $1
 */
endsnippet

# draw a fix length comment with string in it
# example: 50/*
# ------------------------------
snippet "(\d+)com" "fixed length comments" r
/*`!p snip.rv = " " * int(int(match.group(1)) - len(t[1]) - int((int(match.group(1)) - len(t[1]))/2) - 3)` ${1:COMMENT} `!p snip.rv = " " * int((int(match.group(1)) - len(t[1]))/2 - 3)`*/
endsnippet

# ==================================================
# ┌────────────────────────────────────────────────┐
# │                     include                    │
# └────────────────────────────────────────────────┘

snippet inc "#include" b
#include <${1:LIBRARY}>
endsnippet

snippet incc "#include" b
#include "${1:LIBRARY}"
endsnippet

snippet "(\w+).inc" "#include" rb
#include <`!p snip.rv = match.group(1)`>
endsnippet

snippet "(\w+).incc" "#include" rb
#include "`!p snip.rv = match.group(1)`.h"
endsnippet

# ==================================================
# ┌────────────────────────────────────────────────┐
# │                     define                     │
# └────────────────────────────────────────────────┘

snippet #hg "header guards" b
#ifndef ${1:PREPROCESSOR_VARIABLE}
#define $1
${2:/*STATEMENTS*/}
#endif
endsnippet

snippet def "#define" b
#define ${1:MACROS}
endsnippet

# ==================================================
# ┌────────────────────────────────────────────────┐
# │                   Declaration                  │
# └────────────────────────────────────────────────┘

snippet td. "typedef"
typedef 
endsnippet

snippet td.. "typedef"
typedef ${1:TYPE} ${2:NAME}
endsnippet

snippet stru "struct declare" w
struct ${1:TYPE} ${2:VARIABLE}
endsnippet

snippet struct "struct define"
struct ${1:TYPE}
{
    ${2:MEMBER}
};
endsnippet

snippet c. "const" w
const 
endsnippet

snippet c.. "const" w
const ${1:TYPE}
endsnippet

snippet s. "static" w
static 
endsnippet

snippet s.. "static" w
static ${1:TYPE}
endsnippet

snippet boolt "bool true" w
bool ${1:NAME} = true;
endsnippet

snippet boolf "bool false" w
bool ${1:NAME} = false;
endsnippet

# ==================================================
# ┌────────────────────────────────────────────────┐
# │                    Function                    │
# └────────────────────────────────────────────────┘

snippet f "simple function"
${2:RETURN} ${1:FUNC_NAME}(${3:PARAMETER})
{
    ${4:STATEMENTS}
}
endsnippet

snippet r "return"
return ${1:RET_VAL};
endsnippet

snippet rt "return true"
return true;
endsnippet

snippet rf "return false"
return false;
endsnippet

snippet main "add main function"
int main(int argc, char *argv[])
{
    ${1:STATEMENTS}
    return 0;
}
endsnippet

# ==================================================
# ┌────────────────────────────────────────────────┐
# │                  Flow Control                  │
# └────────────────────────────────────────────────┘

# ----------------------- if -----------------------

snippet if "simple if"
if(${1:CONDITION})
{
    ${2:STATEMENTS}
}
endsnippet

snippet else "simple else"
else
{
    ${1:STATEMENTS}
}
endsnippet

snippet elif "else if"
else if(${1:CONDITION})
{
    ${2:STATEMENTS}
}
endsnippet

snippet elifs "short else if"
else if(${1:CONDITION}) ${2:STATEMENTS}
endsnippet

# ---------------------- while ---------------------

snippet while "simple while"
while(${1:CONDITION})
{
    ${2:STATEMENTS}
}
endsnippet

snippet do "do"
do
{
    ${1:STATEMENTS}
}
endsnippet

snippet b; "break"
break;
endsnippet

snippet c; "continue"
continue;
endsnippet

# ----------------------- for ----------------------

snippet for "simple for"
for(${1:INITIALIZATION}; ${2:CONDITION}; ${3:ITERATION})
{
    ${4:STATEMENTS}
}
endsnippet

#for from 0 to number or int variable
# ------------------------------
snippet "for([\w\d]+)" "for" r
for(int i = 0; i < `!p snip.rv = match.group(1)`; ++i)
{
    ${1:STATEMENTS}
}
endsnippet
#for from x to y
# ------------------------------
priority 1
snippet "for([\w\d]+)to([\w\d]+)" "for" r
for(int i = `!p snip.rv = match.group(1)`; i < `!p snip.rv = match.group(2)`; ++i)
{
    ${1:STATEMENTS}
}
endsnippet
priority 0

# --------------------- switch ---------------------

snippet switch "switch"
switch(${1:CONDITION})
{
	case ${2:CASE}: ${3:STATEMENTS}
}
endsnippet

snippet case "switch case"
case ${1:CASE}: ${2:STATEMENTS}
endsnippet

snippet default "switch default"
default : ${1:STATEMENTS}
endsnippet

# ==================================================
# ┌────────────────────────────────────────────────┐
# │                       I/O                      │
# └────────────────────────────────────────────────┘

snippet pr "printf"
printf("${1:OUTPUT}");
endsnippet
